<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="https://bterlson.github.io/ecmarkup/ecmarkup.js"></script>
<link rel="stylesheet" href="https://bterlson.github.io/ecmarkup/elements.css">
<pre class=metadata>
  title: ECMAScript Frozen Realms Spec Proposal
  stage: 1
  contributors: Mark S. Miller, Chip Morningstar, Caridy Patiño
  status: draft
  copyright: false
  location: https://rawgit.com/FUDCo/frozen-realms/master/index.html
</pre>

<emu-table id="table-1" caption="Well-known Intrinsic Objects">
    <table>
        <tbody>
            <tr>
                <th>Intrinsic Name</th>
                <th>Global Name</th>
                <th>ECMAScript Language Association</th>
            </tr>
            <tr>
                <td>%SetPrototype%</td>
                <td><code>Set.prototype</code></td>
                <td>…</td>
            </tr>
            <tr>
                <td>%SpawnedRealm%</td>
                <td></td>
                <td>
                    The SpawnedRealm constructor (<emu-xref href="#sec-the-spawnedrealm-constructor"></emu-xref>)
                </td>
            </tr>
            <tr>
                <td>%SpawnedRealmPrototype%</td>
                <td></td>
                <td>
                    The prototype of SpawnedRealm objects (<emu-xref href="#sec-spawnedrealm-objects"></emu-xref>)
                </td>
            </tr>
            <tr>
                <td>%String%</td>
                <td></td>
                <td>…</td>
            </tr>
        </tbody>
    </table>
</emu-table>

<emu-clause id="sec-realms-objects">
    <h1>Realms Objects</h1>

    <emu-note>
      *IMPORTANT* this section references the Realm API <a href="https://github.com/caridy/proposal-realms">spec proposal</a>, specifically, it adds new capabilities to the Realm Objects.
    </emu-note>

    <emu-clause id="sec-properties-of-the-realm-constructor">
        <h1>Properties of the Realm Constructor</h1>

        The value of the [[Prototype]] internal slot of the *Realm* constructor is the intrinsic object %FunctionPrototype%.

        <emu-clause id="sec-realm.immutableroot">
            <h1>Realm.immutableRoot()</h1>

            When the *Realm.immutableRoot* function is called with no arguments, the following steps are taken:

            <emu-alg>
            1. TODO: In order to attain the necessary deep immutability of an immutable root realm, two of its primordials must be modified from the existing standard: An immutable root realm's `Date` object has its `now()` method removed and its default constructor changed to throw a `TypeError` rather than reveal the current time. An immutable root realm's `Math` object has its `random()` method removed.
            </emu-alg>

            <emu-note>
              `Realm.immutableRoot()` obtains an <def>immutable root realm</def> in which all primordials are already transitively immutable. These primordials include *all* the primordials defined as mandatory in ES2017. These primordials must include no other objects or properties beyond those specified here. In an immutable root realm the global object itself is also transitively immutable. Specifically, it contains no host-specific objects. This frozen global object is a plain object whose `[[Prototype]]` is `Object.prototype`, i.e., the `%ObjectPrototype%` intrinsic of that immutable root realm.
            </emu-note>

            <emu-note>
              Since two immutable root realms are forever the same in all ways except object identity, we leave it implementation-defined whether `Realm.immutableRoot()` always creates a fresh one, or always returns the same one. On any given implementation, it must either be always fresh or always the same.
            </emu-note>
        </emu-clause>

    </emu-clause>

    <emu-clause id="sec-properties-of-the-realm-prototype-object">
        <h1>Properties of the Realm Prototype Object</h1>

        <emu-clause id="sec-realm-prototype-spawn">
              <h1>Realm.prototype.spawn([ _endowments_ ])</h1>

              When the *Realm.prototype.spawn* function is called with optional argument _endowments_, the following steps are taken:

              <emu-alg>
              1. Let _parentRealm_ be *this* value.
              1. If Type(_parentRealm_) is not Object, throw a *TypeError* exception.
              1. If _parentRealm_ is not an instance of a concrete subclass of Realm, throw a *TypeError* exception.
              1. Let _spawnedRealm_ be ? CreateSpawnRealm(_parentRealm_).
              1. Let _freshGlobal_ be _childRealm_.[[FreshGlobal]].
              1. If _endowments_ is provided, then
                1. If Type(_endowments_) is not an Object, throw a *TypeError* exception.
                1. Let _props_ be ? ToObject(_endowments_).
                1. Let _keys_ be ? _props_.[[OwnPropertyKeys]]().
                1. Repeat for each element _propName_ of keys in List order,
                  1. Let _propDesc_ be ? _props_.[[GetOwnProperty]](_propName_).
                  1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then
                    1. Let _propValue_ be ? Get(_props_, _propName_).
                    1. Perform ? CreateDataPropertyOrThrow(_freshGlobal_, _propName_, _propValue_).
              1. Return _spawnedRealm_.
              </emu-alg>
        </emu-clause>

    </emu-clause>

</emu-clause>

<emu-clause id="sec-spawnedrealm-objects">
  <h1>SpawnedRealm Objects</h1>

  <emu-clause id="sec-realms-abstracts">
      <h1>Abstract Operations</h1>

      <emu-clause id="sec-createspawnevaluators" aoid="CreateSpawnEvaluators">
          <h1>CreateSpawnEvaluators(_spawnedRealm_)</h1>

          The abstract operation *CreateEvaluators* with argument _spawnedRealm_ performs the following steps:

          <emu-alg>
          1. Assert: _spawnedRealm_ is an instance of a Spawned Realm.
          1. Let _freshGlobal_ be _spawnedRealm_.[[FreshGlobal]].
          1. Let _E_ be a new built-in function object as defined in SpawnedRealm Evaluator Eval Functions (<emu-xref href="#sec-spawnedrealm-evaluator-eval-functions"></emu-xref>).
          1. Let _F_ be a new built-in function object as defined in SpawnedRealm Evaluator Function Functions (<emu-xref href="#sec-spawnedrealm-evaluator-function-functions"></emu-xref>).
          1. Let _eFn_ be BoundFunctionCreate(_E_, _O_, « »).
          1. Let _fFn_ be BoundFunctionCreate(_F_, _O_, « »).
          1. Perform ! DefinePropertyOrThrow(_eFn_, "length", PropertyDescriptor {[[Value]]: 1, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
          1. Perform ! DefinePropertyOrThrow(_fFn_, "length", PropertyDescriptor {[[Value]]: 1, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true}).
          1. Perform ? CreateDataPropertyOrThrow(_freshGlobal_, *"eval"*, _eFn_).
          1. Perform ? CreateDataPropertyOrThrow(_freshGlobal_, *"Function"*, _fFn_).
          </emu-alg>
      </emu-clause>

      <emu-clause id="sec-createspawnrealm" aoid="CreateSpawnRealm">
          <h1>CreateSpawnRealm(_parentRealm_)</h1>

          The abstract operation *CreateSpawnRealm* with argument _parentRealm_ performs the following steps:

          <emu-alg>
          1. Assert: _parentReam_ is an instance of a concrete subclass of Realm.
          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, "%SpawnedRealmPrototype%", « [[Realm]], [[FreshGlobal]], [[GlobalEnv]] »).
          1. Let _freshGlobal_ be ? ObjectCreate(%ObjectPrototype%).
          1. Let _globalEnv_ be ? NewGlobalEnvironment(_freshGlobal_, _freshGlobal_).
          1. Perform ? CreateSpawnEvaluators(_O_).
          1. Set _O_.[[Realm]] to _parentReam_.
          1. Set _O_.[[FreshGlobal]] be _freshGlobal_.
          1. Set _O_.[[GlobalEnv]] be _globalEnv_.
          1. Return _O_.
          </emu-alg>

      </emu-clause>

      <emu-clause id="sec-spawnedrealm-evaluator-eval-functions">
          <h1>SpawnedRealm Evaluator Eval Functions</h1>

          When a evaluator eval function is called with optional argument _src_, the following steps are taken:

          <emu-alg>
          1. Let _O_ be the *this* value.
          1. Assert: _O_ is an instance of a spawned realm.
          1. If _src_ is not provided, return *undefined*.
          1. Return ? PerformSpawnedEval(_src_, _O_, *false*, *false*).
          </emu-alg>

          The *length* property of a Number format function is 1.
      </emu-clause>

      <emu-clause id="sec-spawnedrealm-evaluator-function-functions">
          <h1>SpawnedRealm Evaluator Function Functions</h1>

          When a evaluator Function function is called, the following steps are taken:

          <emu-alg>
          1. TBD.
          </emu-alg>

          The *length* property of a Number format function is 1.
      </emu-clause>

      <emu-clause id="sec-performspawenedeval" aoid="PerformSpawnedEval">
          <h1>Runtime Semantics: PerformSpawnedEval(_x_, _spawnedRealm_, _strictCaller_, _direct_)</h1>

          <p>The abstract operation PerformEval with arguments _x_, _spawnedRealm_, _strictCaller_, and _direct_ performs the following steps:</p>

          <emu-alg>
          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.
          1. If Type(_x_) is not String, return _x_.
          1. Let _script_ be the ECMAScript code that is the result of parsing _x_, interpreted as UTF-16 encoded Unicode text as described in <emu-xref href="#sec-ecmascript-language-types-string-type"></emu-xref>, for the goal symbol |Script|. If the parse fails, throw a *SyntaxError* exception. If any early errors are detected, throw a *SyntaxError* or a *ReferenceError* exception, depending on the type of the error (but see also clause <emu-xref href="#sec-error-handling-and-language-extensions"></emu-xref>). Parsing and early error detection may be interweaved in an implementation dependent manner.
          1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.
          1. Let _body_ be the |ScriptBody| of _script_.
          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.
          1. Else, let _strictEval_ be IsStrict of _script_.
          1. Let _ctx_ be the running execution context. If _direct_ is *true*, _ctx_ will be the execution context that performed the direct eval. If _direct_ is *false*, _ctx_ will be the execution context for the invocation of the `eval` function.
          1. Let _evalRealm_ be _spawnedRealm_.[[Realm]].
          1. If _direct_ is *true*, then
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_ctx_'s LexicalEnvironment).
            1. Let _varEnv_ be _ctx_'s VariableEnvironment.
          1. Else,
            1. Let _lexEnv_ be NewDeclarativeEnvironment(_spawnedRealm_.[[GlobalEnv]]).
            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].
          1. If _strictEval_ is *true*, let _varEnv_ be _lexEnv_.
          1. If _ctx_ is not already suspended, suspend _ctx_.
          1. Let _evalCxt_ be a new ECMAScript code execution context.
          1. Set the _evalCxt_'s Function to *null*.
          1. Set the _evalCxt_'s Realm to _evalRealm_.
          1. Set the _evalCxt_'s ScriptOrModule to _ctx_'s ScriptOrModule.
          1. Set the _evalCxt_'s VariableEnvironment to _varEnv_.
          1. Set the _evalCxt_'s LexicalEnvironment to _lexEnv_.
          1. Push _evalCxt_ on to the execution context stack; _evalCxt_ is now the running execution context.
          1. Let _result_ be EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _strictEval_).
          1. If _result_.[[Type]] is ~normal~, then
            1. Let _result_ be the result of evaluating _body_.
          1. If _result_.[[Type]] is ~normal~ and _result_.[[Value]] is ~empty~, then
            1. Let _result_ be NormalCompletion(*undefined*).
          1. Suspend _evalCxt_ and remove it from the execution context stack.
          1. Resume the context that is now on the top of the execution context stack as the running execution context.
          1. Return Completion(_result_).
          </emu-alg>

          <emu-note>
          <p>
              The eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if the calling context is evaluating formal parameter initializers or if either the code of the calling context or the eval code is strict mode code. Instead such bindings are instantiated in a new VariableEnvironment that is only accessible to the eval code. Bindings introduced by `let`, `const`, or `class` declarations are always instantiated in a new LexicalEnvironment.
          </p>
          </emu-note>

          <emu-note>
          <p>
              PerformSpawnedEval is equivalent to PerformEval in all sense, except that its _lexEnv_ uses the [[GlobalEnv]] from the SpawnedRealm rather than the [[GlobalEnv]] from its underlying Realm.
          </p>
          </emu-note>
      </emu-clause>

  </emu-clause>

  <emu-clause id="sec-the-spawnedrealm-constructor">
      <h1>The SpawnedRealm Constructor</h1>

        The SpawnedRealm constructor is the %SpawnedRealm% intrinsic object. It is not intended to be called as a function or as a constructor and will always throw an exception.
  </emu-clause>

  <emu-clause id="sec-properties-of-the-spawnedrealm-constructor">
      <h1>Properties of the SpawnedRealm Constructor</h1>

      The value of the [[Prototype]] internal slot of the SpawnedRealm constructor is the intrinsic object %FunctionPrototype%.

      The SpawnedRealm constructor has the following properties:

      <emu-clause id="sec-spawnedrealm.prototype">
          <h1>SpawnedRealm.prototype</h1>

          <p>The initial value of SpawnedRealm.prototype is %SpawnedRealmPrototype%.</p>

          <p>This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }.</p>
      </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-realm-prototype-object">
      <h1>Properties of the SpawnedRealm Prototype Object</h1>

      <emu-clause id="sec-spawnedrealm.prototype.eval">
          <h1>SpawnedRealm.prototype.eval(_src_)</h1>

          Synchronously execute a top-level script. The _src_ is interpreted as a Script and evaluated with *this* Value bound to the SpawnedRealm's global object.

          <emu-alg>
          1. Let _O_ be *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have all of the internal slots of a SpawnRealm Instance (<emu-xref href="#sec-properties-of-spawnedrealm-instances"></emu-xref>), throw a *TypeError* exception.
          1. If Type(_src_) is not String, throw a *TypeError* exception.
          1. Return ? PerformSpawnedEval(_src_, _O_, *false*, *false*)
          </emu-alg>
      </emu-clause>

      <emu-clause id="sec-spawnedrealm.prototype.global">
          <h1>get SpawnedRealm.prototype.global</h1>

          SpawnedRealm.prototype.global is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:

          <emu-alg>
          1. Let _O_ be *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have all of the internal slots of a SpawnRealm Instance (<emu-xref href="#sec-properties-of-spawnedrealm-instances"></emu-xref>), throw a *TypeError* exception.
          1. Return _O_.[[FreshGlobal]].
          </emu-alg>
      </emu-clause>

      <emu-clause id="sec-spawnedrealm.prototype.realm">
          <h1>get SpawnedRealm.prototype.realm</h1>

          SpawnedRealm.prototype.realm is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps:

          <emu-alg>
          1. Let _O_ be *this* value.
          1. If Type(_O_) is not Object, throw a *TypeError* exception.
          1. If _O_ does not have all of the internal slots of a SpawnRealm Instance (<emu-xref href="#sec-properties-of-spawnedrealm-instances"></emu-xref>), throw a *TypeError* exception.
          1. Return _O_.[[Realm]].
          </emu-alg>
      </emu-clause>

      <emu-clause id="sec-spawnedrealm.prototype-@@tostringtag">
          <h1>SpawnedRealm.prototype [ @@toStringTag ]</h1>

          The initial value of the @@toStringTag property is the String value "SpawnedRealm".

          This property has the attributes { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: true }.
      </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-spawnedrealm-instances">
      <h1>Properties of SpawnedRealm Instances</h1>

      SpawnedRealm instances are ordinary objects that inherit properties from the SpawnedRealm prototype object (the intrinsic, %SpawnedRealmPrototype%). SpawnedRealm instances are initially created with the internal slots described in <emu-xref href="#table-2"></emu-xref>.

      <emu-table id="table-2" caption="Internal Slots of SpawnedRealm Instances">
          <table>
              <tbody>
                  <tr>
                      <th>Internal Slot</th>
                      <th>Type</th>
                      <th>Description</th>
                  </tr>
                  <tr>
                      <td>[[Realm]]</td>
                      <td>Realm Record</td>
                      <td>The Realm Record for the initial execution context.</td>
                  </tr>
                  <tr>
                      <td>[[FreshGlobal]]</td>
                      <td>Object</td>
                      <td>The fresh global object associated to the SpawnedRealm.</td>
                  </tr>
                  <tr>
                      <td>[[GlobalEnv]]</td>
                      <td>Lexical Environment</td>
                      <td>The global Lexical Environment associated to the SpawnedRealm.</td>
                  </tr>
              </tbody>
          </table>
      </emu-table>

  </emu-clause>

</emu-clause>

<emu-clause id="sec-frozen-realms-objects">
  <h1>Frozen Realms Objects</h1>

  TBD

</emu-clause>
